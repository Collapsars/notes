# The Pragmatic Programmer
*From Journeyman to Master*<br>
by Andrew Hunt, David Thomas

- [Official site](https://pragprog.com/book/tpp/the-pragmatic-programmer)
- [Safari Books Online](https://www.safaribooksonline.com/library/view/the-pragmatic-programmer/020161622X/)

---

## Foreword

## Preface

## Inside Front Cover: Quick Reference Guide
- A summary of the tips and checklists in the book reproduced verbatim for convenience

### Tips

#### 1. Care About Your Craft
#### 2. Think! About Your Work
#### 3. Provide Options, Don't Make Lame Excuses
#### 4. Don't Live with Broken Windows
#### 5. Be a Catalyst for Change
#### 6. Remember the Big Picture
#### 7. Make Quality a Requirements Issue
#### 8. Invest Regularly in Your Knowledge Portfolio
#### 9. Critically Analyze What You Read and Hear
#### 10. It's Both What You Say and the Way You Say It
#### 11. DRY—Don't Repeat Yourself
#### 12. Make It Easy to Reuse
#### 13. Eliminate Effects Between Unrelated Things
#### 14. There Are No Final Decisions
#### 15. Use Tracer Bullets to Find the Target
#### 16. Prototype to Learn
#### 17. Program Close to the Problem Domain
#### 18. Estimate to Avoid Surprises
#### 19. Iterate the Schedule with the Code
#### 20. Keep Knowledge in Plain Text
#### 21. Use the Power of Command Shells
#### 22. Use a Single Editor Well
#### 23. Always Use Source Code Control
#### 24. Fix the Problem, Not the Blame
#### 25. Don't Panic When Debugging
#### 26. "select" Isn't Broken
#### 27. Don't Assume It—Prove It
#### 28. Learn a Text Manipulation Language
#### 29. Write Code That Writes Code
#### 30. You Can't Write Perfect Software
#### 31. Design with Contracts
#### 32. Crash Early
#### 33. Use Assertions to Prevent the Impossible
#### 34. Use Exceptions for Exceptional Problems
#### 35. Finish What You Start
#### 36. Minimize Coupling Between Modules
#### 37. Configure, Don't Integrate
#### 38. Put Abstractions in Code, Details in Metadata
#### 39. Analyze Workflow to Improve Concurrency
#### 40. Design Using Services
#### 41. Always Design for Concurrency
#### 42. Separate Views from Models
#### 43. Use Blackboards to Coordinate Workflow
#### 44. Don't Program by Coincidence
#### 45. Estimate the Order of Your Algorithms
#### 46. Test Your Estimates
#### 47. Refactor Early, Refactor Often
#### 48. Design to Test
#### 49. Test Your Software, or Your Users Will
#### 50. Don't Use Wizard Code You Don't Understand
#### 51. Don't Gather Requirements—Dig for Them
#### 52. Work with a User to Think Like a User
#### 53. Abstractions Live Longer than Details
#### 54. Use a Project Glossary
#### 55. Don't Think Outside the Box—Find the Box
#### 56. Start When You're Ready
#### 57. Some Things Are Better Done than Described
#### 58. Don't Be a Slave to Formal Methods
#### 59. Costly Tools Don't Produce Better Designs
#### 60. Organize Teams Around Functionality
#### 61. Don't Use Manual Procedures
#### 62. Test Early, Test Often, Test Automatically
#### 63. Coding Ain't Done 'Til All the Tests Run
#### 64. Use Saboteurs to Test Your Testing
#### 65. Test State Coverage, Not Code Coverage
#### 66. Find Bugs Once
#### 67. English is Just a Programming Language
#### 68. Build Documentation In, Don't Bolt It On
#### 69. Gently Exceed Your Users' Expectations
#### 70. Sign Your Work

### Checklists

#### Languages to Learn
#### The WISDOM Acrostic
#### How to Maintain Orthogonality
#### Things to Prototype
#### Architectural Questions
#### Debugging Checklist
#### Law of Demeter for Functions
#### How to Program Deliberately
#### When to Refactor
#### Cutting the Gordian Knot
#### Aspects of Testing

## I. A Pragmatic Philosophy

### 1. The Cat Ate My Source Code
### 2. Software Entropy
### 3. Stone Soup and Boiled Frogs
### 4. Good-Enough Software
### 5. Your Knowledge Portfolio
### 6. Communicate!

## II. A Pragmatic Approach

### 7. The Evils of Duplication
### 8. Orthogonality
### 9. Reversibility
### 10. Tracer Bullets
### 11. Prototypes and Post-it Notes
### 12. Domain Languages
### 13. Estimating

## III. The Basic Tools

### 14. The Power of Plain Text
### 15. Shell Games
### 16. Power Editing
### 17. Source Code Control
### 18. Debugging
### 19. Text Manipulation
### 20. Code Generators

## IV. Pragmatic Paranoia

### 21. Design by Contract
### 22. Dead Programs Tell No Lies
### 23. Assertive Programming
### 24. When to Use Exceptions
### 25. How to Balance Resources

## V. Bend, or Break

### 26. Decoupling and the Law of Demeter
### 27. Metaprogramming
### 28. Temporal Coupling
### 29. It's Just a View
### 30. Blackboards

## VI. While You are Coding

### 31. Programming by Coincidence
### 32. Algorithm Speed
### 33. Refactoring
### 34. Code That's Easy to Test
### 35. Evil Wizards

## VII. Before the Project

### 36. The Requirements Pit
### 37. Solving Impossible Puzzles
### 38. Not Until You're Ready
### 39. The Specification Trap
### 40. Circles and Arrows

## VIII. Pragmatic Projects

### 41. Pragmatic Teams
### 42. Ubiquitous Automation
### 43. Ruthless Testing
### 44. It's All Writing
### 45. Great Expectations
### 46. Pride and Prejudice

## Appendices

### A. Resources
### B. Answers to Exercises
